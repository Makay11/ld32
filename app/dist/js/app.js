// Generated by CoffeeScript 1.9.2
var Barrier, Building, Buildings, C69, Enemy, EnemyManager, Entity, GameManager, MS, Minibot, Player, Road, components, keyCodes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

keyCodes = {
  space: 32,
  left: 37,
  right: 39,
  1: 49,
  2: 50,
  3: 51,
  4: 52
};

MS = 8;

$(function() {
  var gameLoop, gameManager, previousTime;
  gameManager = new GameManager();
  $("body").append(gameManager.renderer.domElement);
  $(window).on("resize", function() {
    return gameManager.resize();
  });
  $(document).on("keydown", function(event) {
    return gameManager.keyDown(event);
  });
  previousTime = 0;
  gameLoop = function(time) {
    var delta;
    delta = time - previousTime;
    previousTime = time;
    gameManager.update(delta);
    gameManager.render();
    return requestAnimationFrame(gameLoop);
  };
  return gameLoop();
});

Road = (function() {
  function Road(scene, renderer) {
    var array, geometry, i, index, j, k, l, len, material, ref, ref1, ref2, texture, tile;
    this.tiles = 4;
    this.roadTiles = [];
    this.leftSideWalkTiles = [];
    this.rightSideWalkTiles = [];
    geometry = new THREE.PlaneBufferGeometry(6, 20);
    texture = THREE.ImageUtils.loadTexture("/images/road.png");
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = renderer.getMaxAnisotropy();
    material = new THREE.MeshBasicMaterial({
      map: texture
    });
    for (i = j = 0, ref = this.tiles; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      tile = new THREE.Mesh(geometry, material);
      tile.position.y = i * 20;
      this.roadTiles.push(tile);
      scene.add(tile);
    }
    geometry = new THREE.PlaneBufferGeometry(1.5, 20);
    texture = THREE.ImageUtils.loadTexture("/images/sidewalk.png");
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = renderer.getMaxAnisotropy();
    material = new THREE.MeshBasicMaterial({
      map: texture
    });
    ref1 = [this.leftSideWalkTiles, this.rightSideWalkTiles];
    for (index = k = 0, len = ref1.length; k < len; index = ++k) {
      array = ref1[index];
      for (i = l = 0, ref2 = this.tiles; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        tile = new THREE.Mesh(geometry, material);
        tile.position.x = -3 - 1.5 / 2 + index * (6 + 1.5);
        tile.position.y = i * 20;
        array.push(tile);
        scene.add(tile);
      }
    }
  }

  Road.prototype.update = function(delta) {
    var array, j, len, ref, results, tile;
    ref = [this.roadTiles, this.leftSideWalkTiles, this.rightSideWalkTiles];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      array = ref[j];
      results.push((function() {
        var k, len1, results1;
        results1 = [];
        for (k = 0, len1 = array.length; k < len1; k++) {
          tile = array[k];
          tile.position.y -= MS / 1000 * delta;
          if (tile.position.y <= -20) {
            results1.push(tile.position.y += this.tiles * 20);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return Road;

})();

Entity = (function() {
  function Entity(renderer, textureURL1, horizontalTiles) {
    this.textureURL = textureURL1;
    this.horizontalTiles = horizontalTiles != null ? horizontalTiles : 1;
    this.width = 1;
    this.height = 1.5;
    this.animationTimer = 0;
    this.animationDuration = 500 / this.horizontalTiles;
    this.maxAnisotropy = renderer.getMaxAnisotropy();
    if (this.textureURL) {
      this.texture = this.loadTexture(this.textureURL);
      this.texture.repeat.x = 1 / this.horizontalTiles;
      this.geometry = new THREE.PlaneBufferGeometry(this.width, this.height);
      this.material = new THREE.MeshBasicMaterial({
        map: this.texture
      });
      this.createMesh(this.geometry, this.material);
    }
  }

  Entity.prototype.createMesh = function(geometry1, material1) {
    this.geometry = geometry1;
    this.material = material1;
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.position.z = this.height / 2;
    this.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
    return THREEx.Transparency.init([this.mesh]);
  };

  Entity.prototype.update = function(delta) {
    if (this.horizontalTiles > 1) {
      this.animationTimer += delta || 0;
      if (this.animationTimer >= this.animationDuration) {
        this.animationTimer -= this.animationDuration;
        return this.texture.offset.x = (this.texture.offset.x + 1 / this.horizontalTiles) % 1;
      }
    }
  };

  Entity.prototype.render = function(camera) {
    return THREEx.Transparency.update([this.mesh], camera);
  };

  Entity.prototype.reset = function() {};

  Entity.prototype.loadTexture = function(textureURL) {
    var texture;
    texture = THREE.ImageUtils.loadTexture(textureURL);
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = this.maxAnisotropy;
    return texture;
  };

  Entity.prototype.setTexture = function(texture1, horizontalTiles, animationDuration) {
    this.texture = texture1;
    this.horizontalTiles = horizontalTiles != null ? horizontalTiles : 1;
    this.animationDuration = animationDuration;
    this.texture.repeat.x = 1 / this.horizontalTiles;
    this.texture.offset.x = 0;
    this.material.map = this.texture;
    this.animationTimer = 0;
    return THREEx.Transparency.init([this.mesh]);
  };

  return Entity;

})();

Player = (function(superClass) {
  extend(Player, superClass);

  function Player(renderer) {
    Player.__super__.constructor.call(this, renderer, "/images/running_sprite.png", 8);
    this.energy = 100;
    this.position = 0;
    this.runningSprite = this.texture;
    this.runningSpriteTiles = 8;
    this.runningAnimationDuration = 300 / this.runningSpriteTiles;
    this.setRunning();
    this.jumpSpriteTiles = 6;
    this.jumpAnimationDuration = 300 / this.jumpSpriteTiles;
    this.jumpLeftSprite = this.loadTexture("/images/jump_left_sprite.png");
    this.jumpLeftSprite.repeat.x = 1 / this.jumpSpriteTiles;
    this.jumpRightSprite = this.loadTexture("/images/jump_right_sprite.png");
    this.jumpRightSprite.repeat.x = 1 / this.jumpSpriteTiles;
    this.jumpSpeed = 2 / (this.jumpAnimationDuration * this.jumpSpriteTiles);
  }

  Player.prototype.moveLeft = function() {
    if (this.moving) {
      return;
    }
    if (this.position > -1) {
      this.setTexture(this.jumpLeftSprite, this.jumpSpriteTiles, this.jumpAnimationDuration);
      return this.moving = "left";
    }
  };

  Player.prototype.moveRight = function() {
    if (this.moving) {
      return;
    }
    if (this.position < 1) {
      this.setTexture(this.jumpRightSprite, this.jumpSpriteTiles, this.jumpAnimationDuration);
      return this.moving = "right";
    }
  };

  Player.prototype.update = function(delta) {
    Player.__super__.update.call(this, delta);
    if (this.moving) {
      if (this.moving === "left") {
        this.mesh.position.x -= this.jumpSpeed * delta;
        if (this.mesh.position.x <= this.position - 2) {
          this.position = this.position - 2;
          this.mesh.position.x = this.position;
          this.setRunning();
        }
      } else if (this.moving === "right") {
        this.mesh.position.x += this.jumpSpeed * delta;
        if (this.mesh.position.x >= this.position + 2) {
          this.position = this.position + 2;
          this.mesh.position.x = this.position;
          this.setRunning();
        }
      }
    }
    return this.updateEnergy(-10 / 1000 * delta);
  };

  Player.prototype.setRunning = function() {
    this.setTexture(this.runningSprite, this.runningSpriteTiles, this.runningAnimationDuration);
    return this.moving = false;
  };

  Player.prototype.updateEnergy = function(value) {
    this.energy += value;
    if (this.energy > 100) {
      this.energy = 100;
    } else if (this.energy < 0) {
      this.energy = 0;
    }
    $(".energy").width(this.energy + "%");
    return this.energy;
  };

  Player.prototype.reset = function() {
    this.setRunning();
    this.updateEnergy(100);
    this.position = 0;
    return this.mesh.position.x = 0;
  };

  return Player;

})(Entity);

GameManager = (function() {
  function GameManager(width, height) {
    this.width = width || window.innerWidth;
    this.height = height || window.innerHeight;
    this.paused = true;
    this.movementQueue = [];
    this.soundSequence = [];
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(this.width, this.height - 4);
    this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
    this.camera.position.y = -2.5;
    this.camera.position.z = 2;
    this.camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2.2);
    this.createScene();
  }

  GameManager.prototype.createScene = function() {
    var floor, j, len, ref;
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(0x000000, 10, 30);
    this.road = new Road(this.scene, this.renderer);
    this.player = new Player(this.renderer);
    this.scene.add(this.player.mesh);
    this.enemyManager = new EnemyManager(this.renderer, this.scene);
    this.buildings = new Buildings(this.renderer, this.scene);
    this.scene.add(this.createSky());
    ref = this.createBuildingFloors();
    for (j = 0, len = ref.length; j < len; j++) {
      floor = ref[j];
      this.scene.add(floor);
    }
    return this.scene.add(this.createMoon());
  };

  GameManager.prototype.createSky = function() {
    var geometry, material, mesh, texture;
    geometry = new THREE.PlaneBufferGeometry(100, 100);
    texture = THREE.ImageUtils.loadTexture("/images/stars.png");
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = this.renderer.getMaxAnisotropy();
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);
    material = new THREE.MeshBasicMaterial({
      map: texture
    });
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = 7;
    mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI);
    return mesh;
  };

  GameManager.prototype.createBuildingFloors = function() {
    var floor, floors, geometry, index, j, len, material, offsets;
    geometry = new THREE.PlaneBufferGeometry(60, 100);
    material = new THREE.MeshBasicMaterial({
      color: 0x454545
    });
    floors = [new THREE.Mesh(geometry, material), new THREE.Mesh(geometry, material)];
    offsets = [-1, 1];
    for (index = j = 0, len = floors.length; j < len; index = ++j) {
      floor = floors[index];
      floor.position.x = offsets[index] * (3 + 1.5 + 30);
    }
    return floors;
  };

  GameManager.prototype.createMoon = function() {
    var geometry, material, texture;
    geometry = new THREE.PlaneBufferGeometry(1.1, 1.1);
    texture = THREE.ImageUtils.loadTexture("/images/moon.png");
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = this.renderer.getMaxAnisotropy();
    material = new THREE.MeshBasicMaterial({
      map: texture
    });
    this.moon = new THREE.Mesh(geometry, material);
    this.moon.position.set(-2.5, 9, 6);
    this.moon.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
    THREEx.Transparency.init([this.moon]);
    return this.moon;
  };

  GameManager.prototype.renderMoon = function(camera) {
    return THREEx.Transparency.update([this.moon], camera);
  };

  GameManager.prototype.resize = function(width, height) {
    this.width = width || window.innerWidth;
    this.height = height || window.innerHeight;
    this.renderer.setSize(this.width, this.height - 4);
    this.camera.aspect = this.width / this.height;
    return this.camera.updateProjectionMatrix();
  };

  GameManager.prototype.keyDown = function(event) {
    var callback, key, options;
    key = event.keyCode;
    if (key === keyCodes.space) {
      if (this.gameOver) {
        location.reload();
      } else {
        this.paused = !this.paused;
      }
      if (this.paused) {
        this.music.stop();
        if (this.musicTimeout) {
          return clearTimeout(this.musicTimeout);
        }
      } else if (this.music) {
        return this.music.play();
      } else if (AudioFX.supported.mp3) {
        options = {
          loop: true,
          autoplay: true,
          volume: 1
        };
        if (!AudioFX.supported.loop) {
          delete options.loop;
          if (this.musicTimeout) {
            clearTimeout(this.musicTimeout);
          }
          callback = function() {
            this.music.play();
            return this.musicTimeout = setTimeout(callback, 5 * 60 * 1000 + 43 * 1000 + 3000);
          };
        }
        return this.music = AudioFX("/audio/Cottonmouth_Timeshift.mp3", options, callback);
      }
    } else if (!this.paused) {
      switch (key) {
        case keyCodes.left:
          if (this.movementQueue.length < 2 && !(this.player.position === 0 && this.player.moving === "left")) {
            this.movementQueue.push("left");
          }
          break;
        case keyCodes.right:
          if (this.movementQueue.length < 2 && !(this.player.position === 0 && this.player.moving === "right")) {
            this.movementQueue.push("right");
          }
      }
      if ((49 <= key && key <= 52)) {
        return this.playSound(key);
      }
    }
  };

  GameManager.prototype.playSound = function(key) {
    this.soundSequence.push(key);
    if (!this.player.moving) {
      return this.enemyManager.attack(this.player, this.soundSequence);
    }
  };

  GameManager.prototype.update = function(delta) {
    var dead, energy, ref;
    if (this.paused) {
      return;
    }
    this.road.update(delta);
    if (!this.player.moving && this.movementQueue.length > 0) {
      switch (this.movementQueue[0]) {
        case "left":
          this.player.moveLeft();
          break;
        case "right":
          this.player.moveRight();
      }
      this.movementQueue.splice(0, 1);
    }
    this.buildings.update(delta);
    energy = this.player.update(delta);
    dead = this.enemyManager.update(delta, this.player, this.camera);
    if (!energy || dead) {
      this.paused = true;
      this.gameOver = true;
      return (ref = this.music) != null ? ref.stop() : void 0;
    }
  };

  GameManager.prototype.render = function() {
    if (this.paused) {
      return;
    }
    this.enemyManager.render(this.camera);
    this.player.render(this.camera);
    this.renderMoon(this.camera);
    return this.renderer.render(this.scene, this.camera);
  };

  return GameManager;

})();

EnemyManager = (function() {
  function EnemyManager(renderer1, scene1) {
    this.renderer = renderer1;
    this.scene = scene1;
    this.nextSpawn = 0;
    this.probabilities = {
      c69: {
        any: 0.3,
        colors: {
          grey: 0.5,
          red: 0.8,
          purple: 0.95,
          golden: 1
        }
      },
      minibot: {
        any: 0.8,
        colors: {
          green: 0.1,
          grey: 0.5,
          blue: 0.6,
          red: 0.8,
          purple: 0.95,
          golden: 1
        }
      },
      barrier: {
        any: 1,
        kinds: {
          sand: 0.33,
          barrier: 0.66,
          sand_barrier: 1
        }
      }
    };
    this.liveEnemies = [];
    this.enemyPool = {
      c69: {
        grey: [],
        golden: [],
        red: [],
        purple: []
      },
      minibot: {
        green: [],
        grey: [],
        blue: [],
        golden: [],
        red: [],
        purple: []
      },
      barrier: {
        sand: [],
        barrier: [],
        sand_barrier: []
      }
    };
  }

  EnemyManager.prototype.render = function(camera) {
    var enemy, j, len, ref, results;
    ref = this.liveEnemies;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      enemy = ref[j];
      results.push(enemy.render(camera));
    }
    return results;
  };

  EnemyManager.prototype.update = function(delta, player, camera) {
    var canCollide, dead, enemy, enemyDied, enemyX, index, j, len, playerX, ref, wasSet;
    dead = false;
    wasSet = false;
    ref = this.liveEnemies;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      enemy = ref[index];
      if (!enemy.collided && enemy.mesh.position.y > 0) {
        canCollide = true;
      }
      enemy.update(delta);
      if (canCollide && enemy.mesh.position.y < 0.2) {
        enemyX = enemy.mesh.position.x;
        playerX = player.mesh.position.x;
        if (enemyX - enemy.width / 2 <= playerX + player.width / 2 && playerX - player.width / 2 <= enemyX + enemy.width / 2) {
          enemy.collided = true;
          dead = true;
        }
      }
      if (enemy.mesh.position.y <= camera.position.y) {
        enemyDied = true;
        this.liveEnemies[index] = null;
        this.stashEnemy(enemy);
      }
      if (!wasSet && enemy.mesh.position.y > 0 && enemy.mesh.position.x === player.mesh.position.x) {
        $(".sequenceOverlay .text").text(enemy.sequenceText);
        wasSet = true;
      }
    }
    if (enemyDied) {
      this.liveEnemies = this.liveEnemies.filter(function(o) {
        return !!o;
      });
    }
    this.handleSpawn(delta);
    return dead;
  };

  EnemyManager.prototype.handleSpawn = function(delta) {
    this.nextSpawn -= delta || 0;
    if (this.nextSpawn <= 0) {
      this.nextSpawn = this.generateNextSpawn();
      return this.spawnEnemy();
    }
  };

  EnemyManager.prototype.generateNextSpawn = function() {
    return Math.floor((Math.random() * 0.75 + 0.25) * 1000 / 1);
  };

  EnemyManager.prototype.spawnEnemy = function() {
    var colors, enemy, kinds, r;
    r = Math.random();
    if (r <= this.probabilities.c69.any) {
      r = Math.random();
      colors = this.probabilities.c69.colors;
      if (r <= colors.grey) {
        enemy = this.enemyPool.c69.grey.pop() || new C69(this.renderer, "grey");
      } else if (r <= colors.red) {
        enemy = this.enemyPool.c69.red.pop() || new C69(this.renderer, "red");
      } else if (r <= colors.purple) {
        enemy = this.enemyPool.c69.purple.pop() || new C69(this.renderer, "purple");
      } else if (r <= colors.golden) {
        enemy = this.enemyPool.c69.golden.pop() || new C69(this.renderer, "golden");
      }
    } else if (r <= this.probabilities.minibot.any) {
      r = Math.random();
      colors = this.probabilities.minibot.colors;
      if (r <= colors.green) {
        enemy = this.enemyPool.minibot.green.pop() || new Minibot(this.renderer, "green");
      } else if (r <= colors.grey) {
        enemy = this.enemyPool.minibot.grey.pop() || new Minibot(this.renderer, "grey");
      } else if (r <= colors.blue) {
        enemy = this.enemyPool.minibot.blue.pop() || new Minibot(this.renderer, "blue");
      } else if (r <= colors.red) {
        enemy = this.enemyPool.minibot.red.pop() || new Minibot(this.renderer, "red");
      } else if (r <= colors.purple) {
        enemy = this.enemyPool.minibot.purple.pop() || new Minibot(this.renderer, "purple");
      } else if (r <= colors.golden) {
        enemy = this.enemyPool.minibot.golden.pop() || new Minibot(this.renderer, "golden");
      }
    } else if (r <= this.probabilities.barrier.any) {
      r = Math.random();
      kinds = this.probabilities.barrier.kinds;
      if (r <= kinds.sand) {
        enemy = this.enemyPool.barrier.sand.pop() || new Barrier(this.renderer, "sand");
      } else if (r <= kinds.barrier) {
        enemy = this.enemyPool.barrier.barrier.pop() || new Barrier(this.renderer, "barrier");
      } else if (r <= kinds.sand_barrier) {
        enemy = this.enemyPool.barrier.sand_barrier.pop() || new Barrier(this.renderer, "sand_barrier");
      }
    }
    this.liveEnemies.push(enemy);
    return this.scene.add(enemy.mesh);
  };

  EnemyManager.prototype.stashEnemy = function(enemy) {
    this.scene.remove(enemy.mesh);
    this.enemyPool[enemy.type][enemy.color || enemy.kind].push(enemy);
    return enemy.reset();
  };

  EnemyManager.prototype.attack = function(player, soundSequence) {
    var enemy, index, j, len, ref, results, score;
    ref = this.liveEnemies;
    results = [];
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      enemy = ref[index];
      if (enemy.mesh.position.y > 0 && enemy.mesh.position.x === player.mesh.position.x) {
        if (score = enemy.attack(soundSequence)) {
          this.liveEnemies.splice(index, 1);
          this.stashEnemy(enemy);
          player.updateEnergy(20);
          $(".score .text").text(parseInt($(".score .text").text()) + score);
          $(".monstersKilled .text").text(parseInt($(".monstersKilled .text").text()) + 1);
        }
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return EnemyManager;

})();

components = null;

(function() {
  var generateComponents, geometry;
  geometry = new THREE.PlaneBufferGeometry(1, 1.5);
  generateComponents = function(textureName) {
    return {
      material: new THREE.MeshBasicMaterial({
        map: Entity.prototype.loadTexture("/images/" + textureName + ".png")
      }),
      geometry: geometry
    };
  };
  return components = {
    c69: {
      grey: generateComponents("c69_grey"),
      golden: generateComponents("c69_golden"),
      red: generateComponents("c69_red"),
      purple: generateComponents("c69_purple")
    },
    minibot: {
      green: generateComponents("minibot_green"),
      grey: generateComponents("minibot_grey"),
      blue: generateComponents("minibot_blue"),
      golden: generateComponents("minibot_golden"),
      red: generateComponents("minibot_red"),
      purple: generateComponents("minibot_purple")
    },
    barrier: {
      sand: generateComponents("sand"),
      barrier: generateComponents("barrier"),
      sand_barrier: generateComponents("sand_barrier")
    }
  };
})();

Enemy = (function(superClass) {
  extend(Enemy, superClass);

  function Enemy(renderer, components) {
    Enemy.__super__.constructor.call(this, renderer);
    this.createMesh(components.geometry, components.material);
    this.movementSpeed = MS / 1000;
    this.collided = false;
    this.mesh.position.x = Math.floor(Math.random() * 3 / 1) * 2 - 2;
    this.mesh.position.y = 25;
  }

  Enemy.prototype.update = function(delta) {
    return this.mesh.position.y -= this.movementSpeed * delta;
  };

  Enemy.prototype.reset = function() {
    this.mesh.position.x = Math.floor(Math.random() * 3 / 1) * 2 - 2;
    this.mesh.position.y = 25;
    return this.collided = false;
  };

  Enemy.prototype.attack = function(soundSequence) {
    if (this.matchSequence(soundSequence)) {
      soundSequence.splice(0, soundSequence.length);
      return this.score;
    }
    return 0;
  };

  Enemy.prototype.matchSequence = function(soundSequence) {
    var index, j, len, length, ref, sound;
    length = soundSequence.length;
    if (length < this.sequence.length) {
      return false;
    }
    ref = this.sequence;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      sound = ref[index];
      if (soundSequence[length - this.sequence.length + index] !== sound) {
        return false;
      }
    }
    return true;
  };

  return Enemy;

})(Entity);

C69 = (function(superClass) {
  extend(C69, superClass);

  function C69(renderer, color) {
    this.color = color;
    C69.__super__.constructor.call(this, renderer, components.c69[this.color]);
    this.type = "c69";
    this.sequenceText = "";
    this.score = 20;
    switch (this.color) {
      case "grey":
        this.score *= 1;
        this.sequence = "1 2 3";
        break;
      case "golden":
        this.score *= 4;
        this.sequence = "1 2 1";
        break;
      case "red":
        this.score *= 2;
        this.sequence = "1 3 2";
        break;
      case "purple":
        this.score *= 3;
        this.sequence = "1 4 2";
    }
    this.sequenceText = this.sequence;
    this.sequence = this.sequence.split(" ").map(function(n) {
      return keyCodes[n];
    });
  }

  return C69;

})(Enemy);

Minibot = (function(superClass) {
  extend(Minibot, superClass);

  function Minibot(renderer, color) {
    this.color = color;
    Minibot.__super__.constructor.call(this, renderer, components.minibot[this.color]);
    this.type = "minibot";
    this.sequenceText = "";
    this.score = 10;
    switch (this.color) {
      case "green":
        this.score *= 1 / 2;
        this.sequence = "1";
        break;
      case "grey":
        this.score *= 1;
        this.sequence = "1 2";
        break;
      case "blue":
        this.score *= 2;
        this.sequence = "1 3";
        break;
      case "golden":
        this.score *= 5;
        this.sequence = "3 1";
        break;
      case "red":
        this.score *= 3;
        this.sequence = "1 4";
        break;
      case "purple":
        this.score *= 4;
        this.sequence = "4 2";
    }
    this.sequenceText = this.sequence;
    this.sequence = this.sequence.split(" ").map(function(n) {
      return keyCodes[n];
    });
  }

  return Minibot;

})(Enemy);

Barrier = (function(superClass) {
  extend(Barrier, superClass);

  function Barrier(renderer, kind) {
    this.kind = kind;
    Barrier.__super__.constructor.call(this, renderer, components.barrier[this.kind]);
    this.type = "barrier";
  }

  Barrier.prototype.attack = function() {
    return 0;
  };

  return Barrier;

})(Enemy);

Buildings = (function() {
  function Buildings(renderer, scene1) {
    var createMaterial, j, k, len, ref, ref1, xOffset, yOffset;
    this.scene = scene1;
    this.width = 3;
    this.heights = {
      small: this.width * 1200 / 750,
      medium: this.width * 1500 / 750,
      large: this.width * 1700 / 750
    };
    this.interval = 2;
    this.buildingsNumber = Math.ceil(30 / (this.width + this.interval));
    this.buildings = [];
    this.buildingPool = {
      small: [],
      medium: [],
      large: []
    };
    createMaterial = function(textureName) {
      var texture;
      texture = THREE.ImageUtils.loadTexture("/images/building_" + textureName + ".png");
      texture.minFilter = THREE.LinearFilter;
      texture.anisotropy = renderer.getMaxAnisotropy();
      return new THREE.MeshBasicMaterial({
        map: texture
      });
    };
    this.components = {
      small: {
        material: createMaterial("small"),
        geometry: new THREE.BoxGeometry(this.width, this.heights.small, this.width)
      },
      medium: {
        material: createMaterial("medium"),
        geometry: new THREE.BoxGeometry(this.width, this.heights.medium, this.width)
      },
      large: {
        material: createMaterial("large"),
        geometry: new THREE.BoxGeometry(this.width, this.heights.large, this.width)
      }
    };
    this.sizes = Object.keys(this.heights);
    ref = [-1, 1];
    for (j = 0, len = ref.length; j < len; j++) {
      xOffset = ref[j];
      for (yOffset = k = 0, ref1 = this.buildingsNumber; 0 <= ref1 ? k < ref1 : k > ref1; yOffset = 0 <= ref1 ? ++k : --k) {
        this.spawnBuilding(xOffset, yOffset);
      }
    }
  }

  Buildings.prototype.spawnBuilding = function(xOffset, yOffset) {
    var building, size;
    size = this.sizes[Math.floor(Math.random() * this.sizes.length / 1)];
    building = this.buildingPool[size].pop() || this.createBuilding(size);
    building.mesh.position.x = xOffset * (3 + 1.5 + this.width / 2);
    building.mesh.position.y = this.width / 2 + yOffset * (this.width + this.interval);
    this.buildings.push(building);
    return this.scene.add(building.mesh);
  };

  Buildings.prototype.createBuilding = function(size) {
    var building;
    building = new Building(size, this.components[size]);
    building.mesh.position.z = this.heights[size] / 2;
    building.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
    return building;
  };

  Buildings.prototype.update = function(delta) {
    var building, index, j, len, ref, removedBuilding;
    ref = this.buildings;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      building = ref[index];
      building.mesh.position.y -= MS / 1000 * delta;
      if (building.mesh.position.y <= this.width / 2 - (this.width + this.interval)) {
        removedBuilding = true;
        this.buildings[index] = null;
        this.scene.remove(building.mesh);
        this.buildingPool[building.size].push(building);
        this.spawnBuilding(Math.sign(building.mesh.position.x), this.buildingsNumber - 1);
      }
    }
    if (removedBuilding) {
      return this.buildings = this.buildings.filter(function(o) {
        return !!o;
      });
    }
  };

  return Buildings;

})();

Building = (function() {
  function Building(size1, components) {
    this.size = size1;
    this.mesh = new THREE.Mesh(components.geometry, components.material);
  }

  return Building;

})();
