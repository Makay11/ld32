// Generated by CoffeeScript 1.9.2
var Enemy, Enemy_C69, Enemy_Minibot, Entity, GameManager, Player, defer, keyCodes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defer = function(f) {
  return setTimeout(function() {
    return f();
  });
};

keyCodes = {
  space: 32,
  left: 37,
  right: 39,
  1: 49,
  2: 50,
  3: 51,
  4: 52
};

defer(function() {
  var gameLoop, gameManager, previousTime;
  gameManager = new GameManager();
  $("body").append(gameManager.renderer.domElement);
  $(window).on("resize", function() {
    return gameManager.resize();
  });
  $(document).on("keydown", function(event) {
    return gameManager.keyDown(event);
  });
  previousTime = 0;
  gameLoop = function(time) {
    var delta;
    requestAnimationFrame(gameLoop);
    delta = time - previousTime;
    previousTime = time;
    gameManager.update(delta);
    return gameManager.render();
  };
  return gameLoop();
});

Entity = (function() {
  function Entity(renderer, textureURL1, horizontalTiles) {
    this.textureURL = textureURL1;
    this.horizontalTiles = horizontalTiles != null ? horizontalTiles : 1;
    this.width = 1;
    this.height = 1.5;
    this.animationTimer = 0;
    this.animationDuration = 500 / this.horizontalTiles;
    this.maxAnisotropy = renderer.getMaxAnisotropy();
    this.texture = this.loadTexture(this.textureURL);
    this.texture.repeat.x = 1 / this.horizontalTiles;
    this.geometry = new THREE.PlaneBufferGeometry(this.width, this.height);
    this.material = new THREE.MeshBasicMaterial({
      map: this.texture
    });
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.position.z = this.height / 2;
    this.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
  }

  Entity.prototype.update = function(delta) {
    if (this.horizontalTiles > 1) {
      this.animationTimer += delta || 0;
      if (this.animationTimer >= this.animationDuration) {
        this.animationTimer -= this.animationDuration;
        return this.texture.offset.x = (this.texture.offset.x + 1 / this.horizontalTiles) % 1;
      }
    }
  };

  Entity.prototype.reset = function() {};

  Entity.prototype.loadTexture = function(textureURL) {
    var texture;
    texture = THREE.ImageUtils.loadTexture(textureURL);
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = this.maxAnisotropy;
    return texture;
  };

  Entity.prototype.setTexture = function(texture1, horizontalTiles, animationDuration) {
    this.texture = texture1;
    this.horizontalTiles = horizontalTiles != null ? horizontalTiles : 1;
    this.animationDuration = animationDuration;
    this.texture.repeat.x = 1 / this.horizontalTiles;
    this.texture.offset.x = 0;
    this.material.map = this.texture;
    return this.animationTimer = 0;
  };

  return Entity;

})();

Player = (function(superClass) {
  extend(Player, superClass);

  function Player(renderer) {
    Player.__super__.constructor.call(this, renderer, "/images/running_sprite.png", 8);
    this.position = 0;
    this.moving = false;
    this.energy = 100;
    this.runningSprite = this.texture;
    this.runningSpriteTiles = 8;
    this.runningAnimationDuration = 500 / this.runningSpriteTiles;
    this.jumpSpriteTiles = 6;
    this.jumpAnimationDuration = 300 / this.jumpSpriteTiles;
    this.jumpLeftSprite = this.loadTexture("/images/jump_left_sprite.png");
    this.jumpLeftSprite.repeat.x = 1 / this.jumpSpriteTiles;
    this.jumpRightSprite = this.loadTexture("/images/jump_right_sprite.png");
    this.jumpRightSprite.repeat.x = 1 / this.jumpSpriteTiles;
    this.jumpSpeed = 2 / (this.jumpAnimationDuration * this.jumpSpriteTiles);
  }

  Player.prototype.moveLeft = function() {
    if (this.moving) {
      return;
    }
    if (this.position > -1) {
      this.setTexture(this.jumpLeftSprite, this.jumpSpriteTiles, this.jumpAnimationDuration);
      return this.moving = "left";
    }
  };

  Player.prototype.moveRight = function() {
    if (this.moving) {
      return;
    }
    if (this.position < 1) {
      this.setTexture(this.jumpRightSprite, this.jumpSpriteTiles, this.jumpAnimationDuration);
      return this.moving = "right";
    }
  };

  Player.prototype.update = function(delta) {
    Player.__super__.update.call(this, delta);
    if (this.moving) {
      if (this.moving === "left") {
        this.mesh.position.x -= this.jumpSpeed * delta;
        if (this.mesh.position.x <= this.position - 2) {
          this.position = this.position - 2;
          this.mesh.position.x = this.position;
          this.setRunning();
        }
      } else if (this.moving === "right") {
        this.mesh.position.x += this.jumpSpeed * delta;
        if (this.mesh.position.x >= this.position + 2) {
          this.position = this.position + 2;
          this.mesh.position.x = this.position;
          this.setRunning();
        }
      }
    }
    return this.updateEnergy(-10 / 1000 * delta);
  };

  Player.prototype.setRunning = function() {
    this.setTexture(this.runningSprite, this.runningSpriteTiles, this.runningAnimationDuration);
    return this.moving = false;
  };

  Player.prototype.updateEnergy = function(value) {
    this.energy += value;
    if (this.energy > 100) {
      this.energy = 100;
    } else if (this.energy < 0) {
      this.energy = 0;
    }
    return $(".energy").width(this.energy + "%");
  };

  return Player;

})(Entity);

GameManager = (function() {
  function GameManager(width, height) {
    this.width = width || window.innerWidth;
    this.height = height || window.innerHeight;
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(this.width, this.height - 4);
    this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
    this.camera.position.y = -2.5;
    this.camera.position.z = 2;
    this.camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2.2);
    this.paused = true;
    this.enemies = [];
    this.enemyPool = [];
    this.transparentObjects = [];
    this.movementQueue = [];
    this.nextSpawn = 0;
    this.soundSequence = [];
    this.createScene();
  }

  GameManager.prototype.createScene = function() {
    var geometry, material, plane;
    this.scene = new THREE.Scene();
    geometry = new THREE.PlaneBufferGeometry(6, 20);
    material = new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture("/images/road.png")
    });
    plane = new THREE.Mesh(geometry, material);
    plane.position.y = this.camera.position.y + 10;
    this.scene.add(plane);
    this.player = new Player(this.renderer);
    this.scene.add(this.player.mesh);
    return this.addTransparentObject(this.player);
  };

  GameManager.prototype.addTransparentObject = function(o) {
    this.transparentObjects.push(o.mesh);
    return THREEx.Transparency.init(this.transparentObjects);
  };

  GameManager.prototype.resize = function(width, height) {
    this.width = width || window.innerWidth;
    this.height = height || window.innerHeight;
    this.renderer.setSize(this.width, this.height - 4);
    this.camera.aspect = this.width / this.height;
    return this.camera.updateProjectionMatrix();
  };

  GameManager.prototype.keyDown = function(event) {
    var key;
    key = event.keyCode;
    if (key === keyCodes.space) {
      return this.paused = !this.paused;
    } else if (!this.paused) {
      switch (key) {
        case keyCodes.left:
          if (this.movementQueue.length < 2 && !(this.player.position === 0 && this.player.moving === "left")) {
            this.movementQueue.push("left");
          }
          break;
        case keyCodes.right:
          if (this.movementQueue.length < 2 && !(this.player.position === 0 && this.player.moving === "right")) {
            this.movementQueue.push("right");
          }
      }
      if ((49 <= key && key <= 52)) {
        return this.playSound(key);
      }
    }
  };

  GameManager.prototype.playSound = function(key) {
    var enemy, energy, i, index, len, ref, results;
    this.soundSequence.push(key);
    if (!this.player.moving) {
      ref = this.enemies;
      results = [];
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        enemy = ref[index];
        if (enemy.mesh.position.x === this.player.mesh.position.x) {
          if (energy = enemy.attack(this.soundSequence)) {
            this.enemies.splice(index, 1);
            this.enemyPool.push(enemy);
            this.scene.remove(enemy.mesh);
            enemy.reset();
            this.player.updateEnergy(energy);
            $(".score .text").text(parseInt($(".score .text").text()) + energy);
            $(".monstersKilled .text").text(parseInt($(".monstersKilled .text").text()) + 1);
          }
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  GameManager.prototype.render = function() {
    if (this.paused) {
      return;
    }
    THREEx.Transparency.update(this.transparentObjects, this.camera);
    return this.renderer.render(this.scene, this.camera);
  };

  GameManager.prototype.update = function(delta) {
    var canCollide, enemy, enemyX, i, index, len, playerX, ref;
    if (this.paused) {
      return;
    }
    if (!this.player.moving && this.movementQueue.length > 0) {
      switch (this.movementQueue[0]) {
        case "left":
          this.player.moveLeft();
          break;
        case "right":
          this.player.moveRight();
      }
      this.movementQueue.splice(0, 1);
    }
    this.player.update(delta);
    ref = this.enemies;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      enemy = ref[index];
      if (!enemy.collided && enemy.mesh.position.y > 0) {
        canCollide = true;
      }
      enemy.update(delta);
      if (canCollide && enemy.mesh.position.y < 0.2) {
        enemyX = enemy.mesh.position.x;
        playerX = this.player.mesh.position.x;
        if (enemyX - enemy.width / 2 <= playerX + this.player.width / 2 && playerX - this.player.width / 2 <= enemyX + enemy.width / 2) {
          enemy.collided = true;
          console.log("ded");
        }
      }
      if (enemy.mesh.position.y <= this.camera.position.y) {
        this.enemies[index] = null;
        this.enemyPool.push(enemy);
        this.scene.remove(enemy.mesh);
      }
    }
    this.enemies = this.enemies.filter(function(o) {
      return !!o;
    });
    this.nextSpawn -= delta || 0;
    if (this.nextSpawn <= 0) {
      if (this.enemyPool.length > 0) {
        enemy = this.enemyPool.pop();
        enemy.reset();
      } else {
        if (Math.random() < 0.7) {
          enemy = new Enemy_Minibot(this.renderer);
        } else {
          enemy = new Enemy_C69(this.renderer);
        }
        this.addTransparentObject(enemy);
      }
      this.enemies.push(enemy);
      this.scene.add(enemy.mesh);
      return this.generateNextSpawn();
    }
  };

  GameManager.prototype.generateNextSpawn = function() {
    return this.nextSpawn = Math.floor(Math.random() * 2 * 1000 / 1);
  };

  return GameManager;

})();

Enemy = (function(superClass) {
  extend(Enemy, superClass);

  function Enemy(renderer, textureURL) {
    Enemy.__super__.constructor.call(this, renderer, textureURL);
    this.movementSpeed = 3 / 1000;
    this.collided = false;
    this.mesh.position.x = Math.floor(Math.random() * 3 / 1) * 2 - 2;
    this.mesh.position.y = 20;
  }

  Enemy.prototype.update = function(delta) {
    return this.mesh.position.y -= this.movementSpeed * delta;
  };

  Enemy.prototype.reset = function() {
    this.mesh.position.x = Math.floor(Math.random() * 3 / 1) * 2 - 2;
    this.mesh.position.y = 20;
    return this.collided = false;
  };

  Enemy.prototype.attack = function(soundSequence) {
    return 0;
  };

  return Enemy;

})(Entity);

Enemy_C69 = (function(superClass) {
  extend(Enemy_C69, superClass);

  function Enemy_C69(renderer) {
    Enemy_C69.__super__.constructor.call(this, renderer, "/images/c69.png");
  }

  Enemy_C69.prototype.attack = function(soundSequence) {
    var length;
    if ((length = soundSequence.length) >= 3) {
      if (soundSequence[length - 3] === keyCodes[1] && soundSequence[length - 2] === keyCodes[2] && soundSequence[length - 1] === keyCodes[1]) {
        soundSequence.splice(0, length);
        return 20;
      }
    }
    return 0;
  };

  return Enemy_C69;

})(Enemy);

Enemy_Minibot = (function(superClass) {
  extend(Enemy_Minibot, superClass);

  function Enemy_Minibot(renderer) {
    Enemy_Minibot.__super__.constructor.call(this, renderer, "/images/minibot.png");
  }

  Enemy_Minibot.prototype.attack = function(soundSequence) {
    var length;
    if ((length = soundSequence.length) >= 2) {
      if (soundSequence[length - 2] === keyCodes[1] && soundSequence[length - 1] === keyCodes[3]) {
        soundSequence.splice(0, length);
        return 10;
      }
    }
    return 0;
  };

  return Enemy_Minibot;

})(Enemy);
